<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Look-around Space</title>
    <style>
        canvas { border: 1px solid black; }
        body { display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; }
    </style>
</head>
<body>
<canvas id="canvas" width="800" height="600"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const cubes = [
    { x: -50, y: 0, z: -100, size: 30 },
    { x: 50, y: 0, z: -100, size: 30 },
    { x: 0, y: 50, z: -100, size: 30 },
];

let angleX = 0, angleY = 0, angleZ = 0;
let motionEnabled = true;

function rotatePoint(point) {
    const { x, y, z } = point;
    // Rotate around Y
    const cosY = Math.cos(angleY);
    const sinY = Math.sin(angleY);
    const rotatedX = x * cosY - z * sinY;
    const rotatedZ = x * sinY + z * cosY;
    // Rotate around X
    const cosX = Math.cos(angleX);
    const sinX = Math.sin(angleX);
    const rotatedY = y * cosX - rotatedZ * sinX;
    const finalZ = y * sinX + rotatedZ * cosX;
    return { x: rotatedX, y: rotatedY, z: finalZ };
}

function project(point) {
    const { x, y, z } = point;
    const scale = 200 / (z + 400);
    const x2d = x * scale + canvas.width / 2;
    const y2d = -y * scale + canvas.height / 2;
    return { x: x2d, y: y2d };
}

function drawCube(cube) {
    const { size } = cube;
    const vertices = [
        { x: -size, y: -size, z: size },
        { x: size, y: -size, z: size },
        { x: size, y: size, z: size },
        { x: -size, y: size, z: size },
        { x: -size, y: -size, z: -size },
        { x: size, y: -size, z: -size },
        { x: size, y: size, z: -size },
        { x: -size, y: size, z: -size },
    ].map(rotatePoint);
    const projected = vertices.map(project);
    ctx.beginPath();
    for (let i = 0; i < 4; i++) {
        ctx.moveTo(projected[i].x, projected[i].y);
        ctx.lineTo(projected[(i + 1) % 4].x, projected[(i + 1) % 4].y);
    }
    for (let i = 4; i < 8; i++) {
        ctx.moveTo(projected[i].x, projected[i].y);
        ctx.lineTo(projected[i-4].x, projected[i-4].y);
    }
    for (let i = 4; i < 8; i++) {
        ctx.moveTo(projected[i].x, projected[i].y);
        ctx.lineTo(projected[(i + 1) % 4 + 4].x, projected[(i + 1) % 4 + 4].y);
    }
    ctx.stroke();
}

function drawGrid() {
    ctx.beginPath();
    for (let i = -200; i < 200; i += 20) {
        ctx.moveTo(i + canvas.width / 2, -200 + canvas.height / 2);
        ctx.lineTo(i + canvas.width / 2, 200 + canvas.height / 2);
        ctx.moveTo(-200 + canvas.width / 2, i + canvas.height / 2);
        ctx.lineTo(200 + canvas.width / 2, i + canvas.height / 2);
    }
    ctx.strokeStyle = 'lightgray';
    ctx.stroke();
}

function update() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawGrid();
    cubes.forEach(drawCube);
    if (motionEnabled) {
        angleY += 0.01;
    }
}

setInterval(update, 50);

// Mock Wii U GamePad integration
const isEnabled = true; // Replace with actual check
const isDataValid = true; // Replace with actual check
if (isEnabled && isDataValid) {
    // Implement motion control updates here
}

</script>
</body>
</html>