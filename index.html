<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <title>Wii U GamePad - 3D Look Around</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        #canvas {
            display: block;
            margin: 0 auto;
            background: #001122;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        #warning {
            color: #ff6b6b;
            font-weight: bold;
        }
        .connected {
            color: #51cf66 !important;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="854" height="480"></canvas>
    <div id="info">
        <div id="warning">Waiting for Wii U GamePad...</div>
        <div>Pitch (Up/Down): <span id="pitch">0.00</span>°</div>
        <div>Yaw (Left/Right): <span id="yaw">0.00</span>°</div>
        <div>Roll (Rotation): <span id="roll">0.00</span>°</div>
        <div style="margin-top: 10px; font-size: 10px;">
            AccZY: <span id="accZY">0.00</span> | angleZ: <span id="angleZ">0.00</span> | angleY: <span id="angleY">0.00</span>
        </div>
    </div>

    <script>
        var canvas = document.getElementById('canvas');
        var ctx = canvas.getContext('2d');
        var width = canvas.width;
        var height = canvas.height;
        
        // Camera rotation
        var cameraPitch = 0;
        var cameraYaw = 0;
        var cameraRoll = 0;
        
        // Dummy data for non-Wii U browsers
        function DummyData() {
            this.hold = 0;
            this.lStickX = 0;
            this.lStickY = 0;
            this.rStickX = 0;
            this.rStickY = 0;
            this.gyroX = 0;
            this.gyroY = 0;
            this.gyroZ = 0;
            this.angleX = 0;
            this.angleY = 0;
            this.angleZ = 0;
            this.accX = 0;
            this.accY = 0;
            this.accZ = 0;
            this.isEnabled = false;
            this.isDataValid = false;
        }
        
        // 3D Point class
        function Point3D(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }
        
        // Rotate point around X axis
        function rotateX(point, angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var y = point.y * cos - point.z * sin;
            var z = point.y * sin + point.z * cos;
            return new Point3D(point.x, y, z);
        }
        
        // Rotate point around Y axis
        function rotateY(point, angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var x = point.x * cos + point.z * sin;
            var z = -point.x * sin + point.z * cos;
            return new Point3D(x, point.y, z);
        }
        
        // Rotate point around Z axis
        function rotateZ(point, angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var x = point.x * cos - point.y * sin;
            var y = point.x * sin + point.y * cos;
            return new Point3D(x, y, point.z);
        }
        
        // Project 3D point to 2D screen
        function project(point) {
            var fov = 500;
            var distance = 5;
            var scale = fov / (fov + point.z + distance);
            var x2d = point.x * scale + width / 2;
            var y2d = -point.y * scale + height / 2;
            return { x: x2d, y: y2d, scale: scale };
        }
        
        // Create a cube
        function createCube(x, y, z, size) {
            var s = size / 2;
            return [
                new Point3D(x - s, y - s, z - s),
                new Point3D(x + s, y - s, z - s),
                new Point3D(x + s, y + s, z - s),
                new Point3D(x - s, y + s, z - s),
                new Point3D(x - s, y - s, z + s),
                new Point3D(x + s, y - s, z + s),
                new Point3D(x + s, y + s, z + s),
                new Point3D(x - s, y + s, z + s)
            ];
        }
        
        // Draw cube edges
        function drawCube(vertices, color) {
            var edges = [
                [0, 1], [1, 2], [2, 3], [3, 0],
                [4, 5], [5, 6], [6, 7], [7, 4],
                [0, 4], [1, 5], [2, 6], [3, 7]
            ];
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            
            for (var i = 0; i < edges.length; i++) {
                var edge = edges[i];
                var p1 = project(vertices[edge[0]]);
                var p2 = project(vertices[edge[1]]);
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }
        }
        
        // Create scene objects
        var objects = [];
        var colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
        
        // Add cubes at various positions
        for (var i = 0; i < 8; i++) {
            var angle = (i / 8) * Math.PI * 2;
            var radius = 300;
            objects.push({
                vertices: createCube(
                    Math.cos(angle) * radius,
                    (Math.random() - 0.5) * 200,
                    Math.sin(angle) * radius,
                    50
                ),
                color: colors[i % colors.length]
            });
        }
        
        // Add a grid floor
        function drawGrid() {
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 1;
            var gridSize = 1000;
            var gridStep = 100;
            
            for (var i = -gridSize; i <= gridSize; i += gridStep) {
                var p1 = new Point3D(i, -200, -gridSize);
                var p2 = new Point3D(i, -200, gridSize);
                p1 = rotateY(rotateX(rotateZ(p1, cameraRoll), cameraPitch), cameraYaw);
                p2 = rotateY(rotateX(rotateZ(p2, cameraRoll), cameraPitch), cameraYaw);
                var proj1 = project(p1);
                var proj2 = project(p2);
                
                ctx.beginPath();
                ctx.moveTo(proj1.x, proj1.y);
                ctx.lineTo(proj2.x, proj2.y);
                ctx.stroke();
                
                p1 = new Point3D(-gridSize, -200, i);
                p2 = new Point3D(gridSize, -200, i);
                p1 = rotateY(rotateX(rotateZ(p1, cameraRoll), cameraPitch), cameraYaw);
                p2 = rotateY(rotateX(rotateZ(p2, cameraRoll), cameraPitch), cameraYaw);
                proj1 = project(p1);
                proj2 = project(p2);
                
                ctx.beginPath();
                ctx.moveTo(proj1.x, proj1.y);
                ctx.lineTo(proj2.x, proj2.y);
                ctx.stroke();
            }
        }
        
        // Update and render
        function update() {
            var state;
            
            if (window.wiiu && window.wiiu.gamepad) {
                state = window.wiiu.gamepad.update();
                if (!state.isEnabled || !state.isDataValid) {
                    state = new DummyData();
                } else {
                    var warningElm = document.getElementById("warning");
                    warningElm.innerHTML = "Wii U GamePad Connected!";
                    warningElm.className = "connected";
                    
                    // CORRECTED CONTROLS based on testing:
                    // AccZY for up/down (most accurate)
                    var accZY = Math.sqrt(state.accZ * state.accZ + state.accY * state.accY);
                    
                    // angleZ for left/right (most accurate)
                    cameraYaw = state.angleZ * 2;
                    
                    // AccZY for up/down pitch control
                    cameraPitch = accZY * 2;
                    
                    // angleY for screen rotation (fixed)
                    cameraRoll = state.angleY;
                    
                    // Update debug display
                    document.getElementById('accZY').textContent = accZY.toFixed(4);
                    document.getElementById('angleZ').textContent = state.angleZ.toFixed(4);
                    document.getElementById('angleY').textContent = state.angleY.toFixed(4);
                }
            } else {
                state = new DummyData();
            }
            
            document.getElementById('pitch').textContent = (cameraPitch * 180 / Math.PI).toFixed(2);
            document.getElementById('yaw').textContent = (cameraYaw * 180 / Math.PI).toFixed(2);
            document.getElementById('roll').textContent = (cameraRoll * 180 / Math.PI).toFixed(2);
            
            ctx.fillStyle = '#001122';
            ctx.fillRect(0, 0, width, height);
            
            drawGrid();
            
            for (var i = 0; i < objects.length; i++) {
                var obj = objects[i];
                var rotatedVertices = [];
                
                for (var j = 0; j < obj.vertices.length; j++) {
                    var v = obj.vertices[j];
                    v = rotateZ(v, cameraRoll);
                    v = rotateX(v, cameraPitch);
                    v = rotateY(v, cameraYaw);
                    rotatedVertices.push(v);
                }
                
                drawCube(rotatedVertices, obj.color);
            }
        }
        
        setInterval(update, 50);
    </script>
</body>
</html>
